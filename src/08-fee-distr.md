# Bao Fee Collection and Distribution

Bao's fee collection and distribution process closely emulates Curve Finance's process with a few key differences. One difference being fees come from usage of Bao Synth markets/products instead of trading fees from LPs like an AMM would generate. Currently the main revenue source is the Bao Markets APR generated by active borrows on the protocol (baoUSD, and others in the future). Another difference relative to curve is that the fee burning process converts all fees generated by the protocol into baoUSD then distributes them to veBAO holders by veBAO weighting.

## The Burn Process

In order to distribute fees from Bao Markets to the Fee Distributor contract every 7 days for veBAO holders to claim the fees the first step is that the DAO multi-sig must call takeProfit() on the [Fed](https://etherscan.io/address/0xD79046A1964F2C40B103Caac3fAe95BAa49E6624#code) contract which withdraws all the fees collected over the 7 days. These fees are then sent to the corresponding burner contract. In the case of baoUSD fees are sent to the [BaseBurner](https://etherscan.io/address/0x9ec01c8315fb3062c9c790c368b0001a84e94a74#code) contract. Once fees have been sent from the fed to the burner contract, the base burner contract has an execute() function and a burn() function. The burn() function will be used in the case of needing to convert any received assets that are not already denominated in baoUSD using the swapping functionality built into the base burner contract before calling execute(). When the base burner contains only the desired fee asset (baoUSD) the execute() function is called to send the entire balance to the fee distributor contract. The Base Burner contract is the last burner to convert any fees sent to it, it can only receive DAI from other burners or baoUSD directly. It will swap any DAI in the contract durng the process of burning to baoUSD using the [Ballast]() contract by calling the burn() function. As for other future burners and the uniswap burner, any fee sources that can not be received in either DAI or baoUSD must first be sent to another burner contract that has functionality in its burn() function to make the swap between the given asset and DAI to be sent to the base burner. In the case of the uniswap burner it will swap any asset on UNI v2 pools (both Uniswap and SushiSwap v2 pools) that has a pairing with DAI using its burn() function as well as transfer funds to the base burner.


### UniswapBurner

```
@external
def burn(_coin: address) -> bool:
    """
    @notice Receive `_coin` and swap it for DAI using Uniswap or Sushi
    @param _coin Address of the coin being converted
    @return bool success
    """

    # ...NOTE, (Line 119) this is where the swap occurs inside the burn function for uniswap burner >>
    # swap for DAI on whichever of uniswap/sushi gives a better rate
    # vyper doesn't support dynamic arrays, so we build the calldata manually
    raw_call(
        router,
        concat(
            method_id("swapExactTokensForTokens(uint256,uint256,address[],address,uint256)"),
            convert(amount, bytes32),           # swap amount
            EMPTY_BYTES32,                      # min expected
            convert(160, bytes32),              # offset pointer to path array
            convert(self.receiver, bytes32),    # receiver of the swap, BASE BURNER is receiver in this case
            convert(block.timestamp, bytes32),  # swap deadline
            convert(3, bytes32),                # path length
            convert(_coin, bytes32),            # input token
            convert(WETH, bytes32),             # weth (intermediate swap)
            convert(DAI, bytes32),              # DAI (final output)
        )
    )
```

### BaseBurner

```
@payable
@external
def burn(_coin: address) -> bool:
    """
    @notice Receive `_coin` and if not already baoUSD, swap for baoUSD using ballast
    @param _coin Address of the coin being received
    @return bool success
    """

    # ...NOTE, (Line 86) the Swap using the ballast is made here, if necessary
    # if not baoUSD, swap it for baoUSD using the ballast
    if _coin != baoUSD:
        if not self.is_approved[_coin]:
            response: Bytes[32] = raw_call(
                _coin,
                concat(
                    method_id("approve(address,uint256)"),
                    convert(ballast, bytes32),
                    convert(MAX_UINT256, bytes32),
                ),
                max_outsize=32,
            )
            if len(response) != 0:
                assert convert(response, bool)
            self.is_approved[_coin] = True

        # get actual balance in case of transfer fee or pre-existing balance
        amount = ERC20(_coin).balanceOf(self)
        if amount != 0:
            Stabilizer(ballast).buy(amount)
```

```
@external
def execute() -> bool:
    """
    @notice transfer baoUSD to the fee distributor
    @return bool success
    """
    assert not self.is_killed  # dev: is killed

    amount: uint256 = ERC20(baoUSD).balanceOf(self)

    if amount != 0:
        ERC20(baoUSD).transfer(self.receiver, amount) #transfer baoUSD to fee distributor

    return True
```
All the baoUSD collected into the base burner contract is then sent into the fee distributor contract. At this point the buring process is done

## Fee Distribution

Once the burning process has occured for the week long period, all the fees collected will then be in the fee distributor contract denominated in baoUSD. At this point veBAO holders can send calls to claim their share of the fees using the claiming functions.

claim_many() will be the function to call for veBAO fee cliaming for most everyone.

```
@external
@nonreentrant('lock')
def claim(_addr: address = msg.sender) -> uint256:
    """
    @notice Claim fees for `_addr`
    @dev Each call to claim look at a maximum of 50 user veBAO points.
         For accounts with many veBAO related actions, this function
         may need to be called more than once to claim all available
         fees. In the `Claimed` event that fires, if `claim_epoch` is
         less than `max_epoch`, the account may claim again.
    @param _addr Address to claim fees for
    @return uint256 Amount of fees claimed in the call
    """
    assert not self.is_killed

    if block.timestamp >= self.time_cursor:
        self._checkpoint_total_supply()

    last_token_time: uint256 = self.last_token_time

    if self.can_checkpoint_token and (block.timestamp > last_token_time + TOKEN_CHECKPOINT_DEADLINE):
        self._checkpoint_token()
        last_token_time = block.timestamp

    last_token_time = last_token_time / WEEK * WEEK

    amount: uint256 = self._claim(_addr, self.voting_escrow, last_token_time)
    if amount != 0:
        token: address = self.token
        assert ERC20(token).transfer(_addr, amount)
        self.token_last_balance -= amount

    return amount
```

```
@external
@nonreentrant('lock')
def claim_many(_receivers: address[20]) -> bool:
    """
    @notice Make multiple fee claims in a single call
    @dev Used to claim for many accounts at once, or to make
         multiple claims for the same address when that address
         has significant veCRV history
    @param _receivers List of addresses to claim for. Claiming
                      terminates at the first `ZERO_ADDRESS`.
    @return bool success
    """
    assert not self.is_killed

    if block.timestamp >= self.time_cursor:
        self._checkpoint_total_supply()

    last_token_time: uint256 = self.last_token_time

    if self.can_checkpoint_token and (block.timestamp > last_token_time + TOKEN_CHECKPOINT_DEADLINE):
        self._checkpoint_token()
        last_token_time = block.timestamp

    last_token_time = last_token_time / WEEK * WEEK
    voting_escrow: address = self.voting_escrow
    token: address = self.token
    total: uint256 = 0

    for addr in _receivers:
        if addr == ZERO_ADDRESS:
            break

        amount: uint256 = self._claim(addr, voting_escrow, last_token_time)
        if amount != 0:
            assert ERC20(token).transfer(addr, amount)
            total += amount

    if total != 0:
        self.token_last_balance -= total

    return True
```